#include "PythonScriptRuntime.h"
#include "PythonLogger.h"

#include <sbkconverter.h>
#include <sbkmodule.h>

#include "backend/core/Project.h"
#include "backend/script/Script.h"
#include "backend/script/ScriptRuntime.h"
#include "pyerrors.h"
#include "pylabplot/pylabplot_python.h"

static wchar_t programName[] = L"labplot";
static wchar_t* argv[] = {programName};
static const wchar_t* pythonInterpreter = L"PYTHON3_EXECUTABLE";

// The name of our python extension module: pylabplot
static const char* moduleName = "pylabplot";

// The python extension module init function for pylabplot generated by shiboken
extern "C" PyObject* PyInit_pylabplot();

// The array of python types provided by pylabplot generated by shiboken from our c++ types
extern PyTypeObject** SbkpylabplotTypes;

// The python interpreter and pylabplot need to be only initialized once for all python scriptruntimes.
// So we used this static variable to track if it is done already
bool PythonScriptRuntime::ready{false};

// To redirect python stdout and stderr to our output in the ScriptEditor, we temporarily replace the
// sys.stdout and sys.stderr objects in python with instances of our PythonLogger class. These variables
// hold the original sys.stdout and sys.stderr objects from python.
PyObject* PythonScriptRuntime::sysStdOutWrite{nullptr};
PyObject* PythonScriptRuntime::sysStdErrWrite{nullptr};

PythonScriptRuntime::PythonScriptRuntime(Script* script)
	: ScriptRuntime(QStringLiteral("Python"), script)
	// PythonLogger instance to replace sys.stdout in the python interpreter
	, m_loggerStdOut(new PythonLogger(this, false))
	// PythonLogger instance to replace sys.stderr in the python interpreter
	, m_loggerStdErr(new PythonLogger(this, true)) {
}

PythonScriptRuntime::~PythonScriptRuntime() {
	// decrease refcount for local context dict to allow python garbage collection
	Py_XDECREF(m_localDict);

	delete m_loggerStdOut;
	delete m_loggerStdErr;
}

bool PythonScriptRuntime::init() {
	// initialize python interpreter and pylabplot module
	bool init = PythonScriptRuntime::initPython();
	if (!init)
		return false;

	// Get sys.stdout
	if (!sysStdOutWrite) {
		PyObject* sysStdOut = PySys_GetObject("stdout");
		if (!sysStdOut)
			return false; // Failed to get sys.stdout

		Py_INCREF(sysStdOut);

		sysStdOutWrite = PyObject_GetAttrString(sysStdOut, "write"); // returns a new reference
		if (!sysStdOutWrite) {
			Py_DECREF(sysStdOut);
			return false; // Failed to get sys.stdout.write
		}
	}

	// Get sys.stderr
	if (!sysStdErrWrite) {
		PyObject* sysStdErr = PySys_GetObject("stderr");
		if (!sysStdErr)
			return false; // Failed to get sys.stderr

		Py_INCREF(sysStdErr);

		sysStdErrWrite = PyObject_GetAttrString(sysStdErr, "write"); // returns a new reference
		if (!sysStdErrWrite) {
			Py_DECREF(sysStdErr);
			return false; // Failed to get sys.stdout.write
		}
	}

	// create a fresh local context where we can execute our scripts
	// to remove variables from previous runs
	m_localDict = PythonScriptRuntime::createLocalDict();
	if (!m_localDict)
		return false;

	return true;
}

bool PythonScriptRuntime::initPython() {
	// Python interpreter and pylabplot module is already initialized
	if (Py_IsInitialized() && ready)
		return true;

	Py_SetProgramName(pythonInterpreter);

	if (PyImport_AppendInittab(moduleName, PyInit_pylabplot) == -1)
		return false; // Failed to add the pylabplot module to the table of built-in modules

	Py_Initialize();

	PySys_SetArgvEx(1, argv, 0);

	const bool pythonInitialized = PyInit_pylabplot() != nullptr;
	const bool pyErrorOccurred = PyErr_Occurred() != nullptr;
	if (!pythonInitialized || pyErrorOccurred)
		return false; // Failed to initialize the pylabplot module

	ready = true;
	return true;
}

bool PythonScriptRuntime::reset() {
	// Python interpreter and pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return false;

	// Create a fresh local context for script execution
	PyObject* localDict = PythonScriptRuntime::createLocalDict();
	if (!localDict) {
		// decrease refcount for local context dict to allow python garbage collection
		Py_XDECREF(m_localDict);
		return false;
	}

	// decrease refcount for local context dict to allow python garbage collection
	Py_XDECREF(m_localDict);

	m_localDict = localDict;

	return true;
}

bool PythonScriptRuntime::cancel() {
	// Python interpreter and pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return false;

	// not yet implemented
	return false;
}

bool PythonScriptRuntime::redirectOutput() {
	// Python interpreter and pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return false;

	int res = -1;

	// Get sys.stdout
	PyObject* sysStdOut = PySys_GetObject("stdout");
	if (!sysStdOut)
		return false; // Failed to get sys.stdout

	Py_INCREF(sysStdOut);

	PyObject* loggerStdOut = PythonScriptRuntime::shibokenConvertToPyObject(SBK_PYTHONLOGGER_IDX, m_loggerStdOut); // returns an owned reference
	if (!loggerStdOut) {
		Py_DECREF(sysStdOut);
		return false; // Failed to convert PythonLogger instance to PyObject
	}

	PyObject* loggerStdOutWrite = PyObject_GetAttrString(loggerStdOut, "write"); // returns a new reference
	if (!loggerStdOutWrite) {
		Py_DECREF(sysStdOut);
		Py_DECREF(loggerStdOut);
		return false; // Failed to get write from loggerStdOut
	}

	res = PyObject_SetAttrString(sysStdOut, "write", loggerStdOutWrite);
	if (res < 0) {
		Py_DECREF(sysStdOut);
		Py_DECREF(loggerStdOut); // shouldn't delete c++ object
		Py_DECREF(loggerStdOutWrite);
		return false; // Failed to set write from loggerStdOut in sys.stdout
	}

	Py_DECREF(sysStdOut);
	Py_DECREF(loggerStdOut); // shouldn't delete c++ object
	Py_DECREF(loggerStdOutWrite);

	// Get sys.stdout
	PyObject* sysStdErr = PySys_GetObject("stderr");
	if (!sysStdErr)
		return false; // Failed to get sys.stderr

	Py_INCREF(sysStdErr);

	PyObject* loggerStdErr = PythonScriptRuntime::shibokenConvertToPyObject(SBK_PYTHONLOGGER_IDX, m_loggerStdErr); // returns an owned reference
	if (!loggerStdErr) {
		Py_DECREF(sysStdErr);
		return false; // Failed to convert PythonLogger instance to PyObject
	}

	PyObject* loggerStdErrWrite = PyObject_GetAttrString(loggerStdErr, "write"); // returns a new reference
	if (!loggerStdErrWrite) {
		Py_DECREF(sysStdErr);
		Py_DECREF(loggerStdErr);
		return false; // Failed to get write from loggerStdErr
	}

	res = PyObject_SetAttrString(sysStdErr, "write", loggerStdErrWrite);
	if (res < 0) {
		Py_DECREF(sysStdErr);
		Py_DECREF(loggerStdErr); // shouldn't delete c++ object
		Py_DECREF(loggerStdErrWrite);
		return false; // Failed to set write from loggerStdErr in sys.stderr
	}

	Py_DECREF(sysStdErr);
	Py_DECREF(loggerStdErr); // shouldn't delete c++ object
	Py_DECREF(loggerStdErrWrite);

	return true;
}

bool PythonScriptRuntime::unRedirectOutput() {
	// Python interpreter and pylabplt module is not initialized
	if (!Py_IsInitialized() || !ready)
		return false;

	int res = -1;

	// Get sys.stdout
	PyObject* sysStdOut = PySys_GetObject("stdout");
	if (!sysStdOut)
		return false; // Failed to get sys.stdout

	Py_INCREF(sysStdOut);

	res = PyObject_SetAttrString(sysStdOut, "write", sysStdOutWrite);
	if (res < 0) {
		Py_DECREF(sysStdOut);
		return false; // Failed to set write from loggerStdOut in sys.stdout
	}

	Py_DECREF(sysStdOut);

	// Get sys.stderr
	PyObject* sysStdErr = PySys_GetObject("stderr");
	if (!sysStdErr)
		return false; // Failed to get sys.stderr

	Py_INCREF(sysStdErr);

	res = PyObject_SetAttrString(sysStdErr, "write", sysStdErrWrite);
	if (res < 0) {
		Py_DECREF(sysStdErr);
		return false; // Failed to set write from loggerStdOut in sys.stderr
	}

	Py_DECREF(sysStdErr);

	return true;
}

bool PythonScriptRuntime::exec(const QString& code) {
	// Python interpreter or pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return false;

	// Failed to create new local context for script execution
	if (!reset())
		return false;

	// Failed to create new local context for script execution
	if (m_localDict == nullptr)
		return false;

	// Redirect python output to output in our ScriptEditor
	if (!redirectOutput())
		return false;

	// Clear any previous errors in the python interpreter
	PyErr_Clear();

	// Compile script to python bytecode
	PyObject* compiled = Py_CompileString(code.toLocal8Bit().constData(), m_name.toLocal8Bit().constData(), Py_file_input);
	if (!compiled) {
		if (PyErr_Occurred()) {
			m_errorLine = PythonScriptRuntime::getPyErrorLine(); // Get the line where the error occurred
			PyErr_Print(); // Print the error to our output in ScriptEditor
			return true; // This is ok
		}
		return false;
	}

	// Clear any previous errors in the python interpreter
	PyErr_Clear();

	// Evaluate the python bytecode
	auto* res = PyEval_EvalCode(compiled, m_localDict, m_localDict);
	if (!res) {
		Py_DECREF(compiled);
		if (PyErr_Occurred()) {
			m_errorLine = PythonScriptRuntime::getPyErrorLine(); // Get the line where the error occurred
			PyErr_Print(); // Print the error to our output in ScriptEditor
			return true; // this is ok
		}
		return false;
	}

	Py_DECREF(compiled);
	Py_DECREF(res);

	// Unredirect python output to output in our ScriptEditor
	if (!unRedirectOutput())
		return false;

	// fetch new variables
	if (!populateVariableInfo())
		return false;

	return true;
}

// Converts a c++ object to a pyobject
// returns an owned reference
PyObject* PythonScriptRuntime::shibokenConvertToPyObject(int index, void* o) {
	// Python interpreter or pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return nullptr;

	PyTypeObject* typeObject = SbkpylabplotTypes[index];

	// returns a borrowed reference
	PyObject* po = Shiboken::Conversions::pointerToPython(reinterpret_cast<SbkObjectType*>(typeObject), o);
	if (!po)
		return nullptr;

	Py_INCREF(po);
	return po;
}

// Returns the dictionary which contains the variables in module
// returns an owned reference
PyObject* PythonScriptRuntime::getModuleDict(const QString& moduleName) {
	// Python interpreter or pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return nullptr;

	// PyImport_AddModule returns a borrowed reference so we create own reference Py_INCREF(o); and Py_DECREF(o); when done
	PyObject* module = PyImport_AddModule(moduleName.toLocal8Bit().constData());
	if (!module) // Failed to locate module
		return nullptr;

	Py_INCREF(module);

	// returns borrowed reference so we create own reference Py_INCREF(o); and Py_DECREF(o); when done
	PyObject* moduleDict = PyModule_GetDict(module);
	if (!moduleDict) {
		Py_DECREF(module);
		// Failed to get module __dict__
		return nullptr;
	}

	Py_DECREF(module);
	Py_INCREF(moduleDict);

	return moduleDict;
}

// Creates a new local context for the execution of our script
// The process is create a dictionary and copy over the python builtins from the main module
// returns owned reference
PyObject* PythonScriptRuntime::createLocalDict() {
	// Python interpreter or pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return nullptr;

	auto* mainDict = PythonScriptRuntime::getModuleDict(QStringLiteral("__main__"));
	if (!mainDict)
		return nullptr;

	// create a dictionary
	auto* localDict = PyDict_New();
	if (!localDict) {
		Py_DECREF(mainDict);
		return nullptr;
	}

	// copy python builtins to the dictionary
	if (PyDict_SetItemString(localDict, "__builtins__", PyDict_GetItemString(mainDict, "__builtins__")) < 0) {
		Py_DECREF(localDict);
		Py_DECREF(mainDict);
		return nullptr;
	}

	Py_DECREF(mainDict);

	if (m_localDict) {
		for (const auto& [name, variableInfo] : m_variableModel->variablesInfo().asKeyValueRange()) {
			if (variableInfo.persist) {
				// copy python variable to the dictionary
				if (PyDict_SetItemString(localDict, name.toLocal8Bit().constData(), PyDict_GetItemString(m_localDict, name.toLocal8Bit().constData())) < 0) {
					Py_DECREF(localDict);
					return nullptr;
				}
			}
		}
	}

	return localDict;
}

// Get the line where the python error occurred
int PythonScriptRuntime::getPyErrorLine() {
	// Python interpreter or pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return -1;

	int errorLine = -1;

	PyObject *type, *value, *traceback;

	PyErr_Fetch(&type, &value, &traceback);
	PyErr_NormalizeException(&type, &value, &traceback);

	if (traceback) {
		PyObject* p = PyObject_GetAttrString(traceback, "tb_lineno");
		if (p) {
			long line = PyLong_AsLong(p);
			if (line >= INT_MIN && line <= INT_MAX)
				errorLine = static_cast<int>(line) - 1;

			Py_DECREF(p);
		}
	}

	if (errorLine == -1 && type && value && PyErr_GivenExceptionMatches(type, PyExc_SyntaxError) != -1) {
		PyObject* q = PyObject_GetAttrString(value, "lineno");
		if (q) {
			long line = PyLong_AsLong(q);
			if (line >= INT_MIN && line <= INT_MAX)
				errorLine = static_cast<int>(line) - 1;

			Py_DECREF(q);
		}
	}

	PyErr_Restore(type, value, traceback);

	return errorLine;
}

bool PythonScriptRuntime::populateVariableInfo() {
	PyObject* items = PyDict_Items(m_localDict);
	if (!items)
		return false;

	QMap<QString, VariableInfo> variablesInfo;

	Py_ssize_t size = PyList_Size(items);

	for (Py_ssize_t i = 0; i < size; ++i) {
		PyObject* item = PySequence_GetItem(items, i);
		if (!item) {
			Py_DECREF(items);
			return false;
		}

		PyObject* keyObj = PySequence_GetItem(item, 0);
		if (!keyObj) {
			Py_DECREF(items);
			Py_DECREF(item);
			return false;
		}

		const QString& key = PythonScriptRuntime::pyUnicodeToQString(keyObj);
		if (key.isNull()) {
			Py_DECREF(items);
			Py_DECREF(item);
			Py_DECREF(keyObj);
			return false;
		}

		Py_DECREF(keyObj);

		if (key.startsWith(QStringLiteral("__"))) {
			Py_DECREF(item);
			continue;
		}

		if (QString::compare(key, QStringLiteral("project"), Qt::CaseSensitive) == 0) {
			Py_DECREF(item);
			continue;
		}

		PyObject* valueObj = PySequence_GetItem(item, 1);
		if (!valueObj) {
			Py_DECREF(items);
			Py_DECREF(item);
			return false;
		}

		if (PyModule_Check(valueObj)) {
			Py_DECREF(item);
			Py_DECREF(valueObj);
			continue;
		}

		if (PyFunction_Check(valueObj)) {
			Py_DECREF(item);
			Py_DECREF(valueObj);
			continue;
		}

		if (PyType_Check(valueObj)) {
			Py_DECREF(item);
			Py_DECREF(valueObj);
			continue;
		}

		PyObject* valueRepr = PyObject_Repr(valueObj);
		if (!valueRepr) {
			Py_DECREF(item);
			Py_DECREF(valueObj);
			Py_DECREF(items);
			return false;
		}

		Py_DECREF(item);
		Py_DECREF(valueObj);

		const QString& value = PythonScriptRuntime::pyUnicodeToQString(valueRepr);
		if (value.isNull()) {
			Py_DECREF(items);
			Py_DECREF(valueRepr);
			return false;
		}

		Py_DECREF(valueRepr);

		const QString& typeQuery = QStringLiteral("type(") + key + QStringLiteral(")");
		PyObject* typeObj = PyRun_String(typeQuery.toLocal8Bit().constData(), Py_eval_input, m_localDict, m_localDict);
		if (!typeObj) {
			Py_DECREF(items);
			return false;
		}

		PyObject* typeRepr = PyObject_Repr(typeObj);
		if (!typeRepr) {
			Py_DECREF(typeObj);
			Py_DECREF(items);
			return false;
		}

		Py_DECREF(typeObj);

		const QString& type = PythonScriptRuntime::pyUnicodeToQString(typeRepr);
		if (type.isNull()) {
			Py_DECREF(items);
			Py_DECREF(typeRepr);
			return false;
		}

		Py_DECREF(typeRepr);

		ScriptRuntime::VariableInfo variableInfo;
		variableInfo.value = value;
		variableInfo.type = type;
		variableInfo.persist = m_variableModel->variablesInfo().contains(key) ? m_variableModel->variablesInfo().value(key).persist : false;

		variablesInfo.insert(key, variableInfo);
	}

	Py_DECREF(items);

	m_variableModel->clearVariablesInfo();
	m_variableModel->setVariablesInfo(variablesInfo);

	return true;
}

QString PythonScriptRuntime::pyUnicodeToQString(PyObject* obj) {
	PyObject* bytes = PyUnicode_AsUTF8String(obj);
	if (!bytes)
		return {};

	char* charPtr = PyBytes_AsString(bytes);
	if (!charPtr) {
		Py_DECREF(bytes);
		return {};
	}

	Py_DECREF(bytes);
	return QString::fromUtf8(charPtr);
}
