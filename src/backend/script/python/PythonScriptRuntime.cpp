#include "PythonScriptRuntime.h"
#include "PythonLogger.h"

#include <Python.h>
#include <sbkconverter.h>
#include <sbkmodule.h>

#include "backend/core/Project.h"
#include "backend/script/Script.h"
#include "backend/script/ScriptRuntime.h"
#include "pyerrors.h"
#include "pylabplot/pylabplot_python.h"

#include <codecvt>
#include <string>

static wchar_t programName[] = L"labplot";
static wchar_t* argv[] = {programName};
static const wchar_t* pythonInterpreter = PYTHON3_EXECUTABLE; // PYTHON3_EXECUTABLE is a macro and will be replaced by the actual python executable name

// The name of our python extension module: pylabplot
static const char* moduleName = "pylabplot";

// The python extension module init function for pylabplot generated by shiboken
extern "C" PyObject* PyInit_pylabplot();

// The array of python types provided by pylabplot generated by shiboken from our c++ types
extern PyTypeObject** SbkpylabplotTypes;

// The python interpreter and pylabplot need to be only initialized once for all python scriptruntimes.
// So we used this static variable to track if it is done already
bool PythonScriptRuntime::ready{false};

// To redirect python stdout and stderr to our output in the ScriptEditor, we temporarily replace the
// sys.stdout and sys.stderr objects in python with instances of our PythonLogger class. These variables
// hold the original sys.stdout and sys.stderr objects from python.
PyObject* PythonScriptRuntime::sysStdOutWrite{nullptr};
PyObject* PythonScriptRuntime::sysStdErrWrite{nullptr};

PythonScriptRuntime::PythonScriptRuntime(Script* script)
	: ScriptRuntime(QStringLiteral("Python"), script)
	// PythonLogger instance to replace sys.stdout in the python interpreter
	, m_loggerStdOut(new PythonLogger(this, false))
	// PythonLogger instance to replace sys.stderr in the python interpreter
	, m_loggerStdErr(new PythonLogger(this, true)) {
}

PythonScriptRuntime::~PythonScriptRuntime() {
	// decrease refcount for local context dict to allow python garbage collection
	Py_XDECREF(m_localDict);

	delete m_loggerStdOut;
	delete m_loggerStdErr;
}

bool PythonScriptRuntime::init() {
	INFO(Q_FUNC_INFO)
	// initialize python interpreter and pylabplot module
	bool init = PythonScriptRuntime::initPython();
	if (!init)
		return false;

	// Get sys.stdout
	if (!sysStdOutWrite) {
		PyObject* sysStdOut = PySys_GetObject("stdout");
		if (!sysStdOut)
			return false; // Failed to get sys.stdout

		Py_INCREF(sysStdOut);

		sysStdOutWrite = PyObject_GetAttrString(sysStdOut, "write"); // returns a new reference
		if (!sysStdOutWrite) {
			Py_DECREF(sysStdOut);
			return false; // Failed to get sys.stdout.write
		}
	}

	// Get sys.stderr
	if (!sysStdErrWrite) {
		PyObject* sysStdErr = PySys_GetObject("stderr");
		if (!sysStdErr)
			return false; // Failed to get sys.stderr

		Py_INCREF(sysStdErr);

		sysStdErrWrite = PyObject_GetAttrString(sysStdErr, "write"); // returns a new reference
		if (!sysStdErrWrite) {
			Py_DECREF(sysStdErr);
			return false; // Failed to get sys.stdout.write
		}
	}

	// create a fresh local context where we can execute our scripts
	// to remove variables from previous runs
	m_localDict = PythonScriptRuntime::createLocalDict();
	if (!m_localDict)
		return false;

	return true;
}

bool PythonScriptRuntime::initPython() {
	INFO(Q_FUNC_INFO)
	// Python interpreter and pylabplot module is already initialized
	if (Py_IsInitialized() && ready)
		return true;

	PyConfig config;
	PyConfig_InitPythonConfig(&config);

	// TODO: use macro for converting wchar_t
	std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
	INFO("Using Python interpreter: " << converter.to_bytes(pythonInterpreter))
	PyConfig_SetString(&config, &config.program_name, pythonInterpreter);
	PyConfig_SetArgv(&config, 1, argv);

	INFO("CALLING PyImport_AppendInittab()")
	if (PyImport_AppendInittab(moduleName, PyInit_pylabplot) == -1) {
		WARN("Failed to add the pylabplot module to the table of built-in modules")
		return false;
	}

	Py_InitializeFromConfig(&config);
	PyConfig_Clear(&config);

	const bool pythonInitialized = PyInit_pylabplot() != nullptr;
	const bool pyErrorOccurred = PyErr_Occurred() != nullptr;
	if (!pythonInitialized || pyErrorOccurred) {
		WARN("Failed to initialize the pylabplot module")
		return false;
	}

	ready = true;
	return true;
}

bool PythonScriptRuntime::reset() {
	INFO(Q_FUNC_INFO)
	// Python interpreter and pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return false;

	// Create a fresh local context for script execution
	PyObject* localDict = PythonScriptRuntime::createLocalDict();
	if (!localDict) {
		// decrease refcount for local context dict to allow python garbage collection
		Py_XDECREF(m_localDict);
		return false;
	}

	// decrease refcount for local context dict to allow python garbage collection
	Py_XDECREF(m_localDict);

	m_localDict = localDict;

	return true;
}

bool PythonScriptRuntime::cancel() {
	// Python interpreter and pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return false;

	// not yet implemented
	return false;
}

bool PythonScriptRuntime::redirectStream(const char* streamName, void* loggerInstance) {
	INFO(Q_FUNC_INFO)
	auto* sysStream = PySys_GetObject(streamName);
	if (!sysStream) {
		WARN("Failed to get" << streamName)
		return false;
	}
	Py_INCREF(sysStream);

	auto* loggerStream = PythonScriptRuntime::shibokenConvertToPyObject(loggerInstance); // returns an owned reference
	// TODO: Segfault
	// auto* loggerStream = Shiboken::Object::newObject(Shiboken::SbkType< ::PythonLogger >(), loggerInstance);	//  returns an owned reference
	if (!loggerStream) {
		WARN("Failed to convert PythonLogger instance to PyObject")
		Py_DECREF(sysStream);
		return false;
	}

	auto* loggerStreamWrite = PyObject_GetAttrString(loggerStream, "write"); // returns a new reference
	if (!loggerStreamWrite) {
		WARN("Failed to get write from loggerStream")
		Py_DECREF(sysStream);
		Py_DECREF(loggerStream);
		return false;
	}

	if (PyObject_SetAttrString(sysStream, "write", loggerStreamWrite) < 0) {
		WARN("Failed to set write from loggerStream in" << streamName)
		Py_DECREF(sysStream);
		Py_DECREF(loggerStream); // shouldn't delete c++ object
		Py_DECREF(loggerStreamWrite);
		return false;
	}
	Py_DECREF(sysStream);
	Py_DECREF(loggerStream); // shouldn't delete c++ object
	Py_DECREF(loggerStreamWrite);

	return true;
}

bool PythonScriptRuntime::redirectOutput() {
	INFO(Q_FUNC_INFO)
	if (!Py_IsInitialized() || !ready) {
		WARN(Q_FUNC_INFO << "Python interpreter or pylabplot module is not initialized")
		return false;
	}

	if (!redirectStream("stdout", m_loggerStdOut))
		return false;

	if (!redirectStream("stderr", m_loggerStdErr))
		return false;

	return true;
}

bool PythonScriptRuntime::unRedirectOutput() {
	// Python interpreter and pylabplt module is not initialized
	if (!Py_IsInitialized() || !ready) {
		WARN(Q_FUNC_INFO << "Python interpreter or pylabplot module is not initialized")
		return false;
	}

	int res = -1;

	// Get sys.stdout
	PyObject* sysStdOut = PySys_GetObject("stdout");
	if (!sysStdOut)
		return false; // Failed to get sys.stdout

	Py_INCREF(sysStdOut);

	res = PyObject_SetAttrString(sysStdOut, "write", sysStdOutWrite);
	if (res < 0) {
		Py_DECREF(sysStdOut);
		return false; // Failed to set write from loggerStdOut in sys.stdout
	}

	Py_DECREF(sysStdOut);

	// Get sys.stderr
	PyObject* sysStdErr = PySys_GetObject("stderr");
	if (!sysStdErr)
		return false; // Failed to get sys.stderr

	Py_INCREF(sysStdErr);

	res = PyObject_SetAttrString(sysStdErr, "write", sysStdErrWrite);
	if (res < 0) {
		Py_DECREF(sysStdErr);
		return false; // Failed to set write from loggerStdOut in sys.stderr
	}

	Py_DECREF(sysStdErr);

	return true;
}

bool PythonScriptRuntime::exec(const QString& code) {
	INFO(Q_FUNC_INFO)
	// Python interpreter or pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return false;

	// Failed to create new local context for script execution
	if (!reset())
		return false;

	// Failed to create new local context for script execution
	if (m_localDict == nullptr)
		return false;

	// Redirect python output to output in our ScriptEditor
	if (!redirectOutput())
		return false;

	// Clear any previous errors in the python interpreter
	PyErr_Clear();

	// Compile script to python bytecode
	PyObject* compiled = Py_CompileString(code.toLocal8Bit().constData(), m_name.toLocal8Bit().constData(), Py_file_input);
	if (!compiled) {
		if (PyErr_Occurred()) {
			m_errorLine = PythonScriptRuntime::getPyErrorLine(); // Get the line where the error occurred
			PyErr_Print(); // Print the error to our output in ScriptEditor
			return true; // This is ok
		}
		return false;
	}

	// Clear any previous errors in the python interpreter
	PyErr_Clear();

	// Evaluate the python bytecode
	auto* res = PyEval_EvalCode(compiled, m_localDict, m_localDict);
	if (!res) {
		Py_DECREF(compiled);
		if (PyErr_Occurred()) {
			m_errorLine = PythonScriptRuntime::getPyErrorLine(); // Get the line where the error occurred
			PyErr_Print(); // Print the error to our output in ScriptEditor
			return true; // this is ok
		}
		return false;
	}

	Py_DECREF(compiled);
	Py_DECREF(res);

	// Unredirect python output to output in our ScriptEditor
	if (!unRedirectOutput())
		return false;

	// fetch new variables
	if (!populateVariableInfo())
		return false;

	return true;
}

// Converts a C++ object to a PyObject (owned reference)
PyObject* PythonScriptRuntime::shibokenConvertToPyObject(void* object) {
	INFO(Q_FUNC_INFO)
	if (!Py_IsInitialized() || !ready)
		return nullptr;

	auto* typeObject = reinterpret_cast<SbkObjectType*>(Shiboken::SbkType<::PythonLogger>());
	// TODO: Crashes "print()"
	// auto* typeObject = SbkType< ::PythonLogger >();
	if (!typeObject) {
		WARN("Failed to get Python type for PythonLogger")
		return nullptr;
	}

	// Create a Python wrapper object for the C++ instance
	PyObject* po = Shiboken::Object::newObject(typeObject, object);

	return po;
}

// Returns the dictionary which contains the variables in module 'name'
// returns an owned reference
PyObject* PythonScriptRuntime::getModuleDict(const QString& name) {
	INFO(Q_FUNC_INFO)
	// Python interpreter or pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return nullptr;

	// PyImport_AddModule returns a borrowed reference so we create own reference Py_INCREF(o); and Py_DECREF(o); when done
	PyObject* module = PyImport_AddModule(name.toLocal8Bit().constData());
	if (!module) // Failed to locate module
		return nullptr;

	Py_INCREF(module);

	// returns borrowed reference so we create own reference Py_INCREF(o); and Py_DECREF(o); when done
	PyObject* moduleDict = PyModule_GetDict(module);
	if (!moduleDict) {
		Py_DECREF(module);
		// Failed to get module __dict__
		return nullptr;
	}

	Py_DECREF(module);
	Py_INCREF(moduleDict);

	return moduleDict;
}

// Creates a new local context for the execution of our script
// The process is create a dictionary and copy over the python builtins from the main module
// returns owned reference
PyObject* PythonScriptRuntime::createLocalDict() {
	INFO(Q_FUNC_INFO)
	// Python interpreter or pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return nullptr;

	auto* mainDict = PythonScriptRuntime::getModuleDict(QStringLiteral("__main__"));
	if (!mainDict)
		return nullptr;

	// create a dictionary
	auto* localDict = PyDict_New();
	if (!localDict) {
		Py_DECREF(mainDict);
		return nullptr;
	}

	// copy python builtins to the dictionary
	if (PyDict_SetItemString(localDict, "__builtins__", PyDict_GetItemString(mainDict, "__builtins__")) < 0) {
		Py_DECREF(localDict);
		Py_DECREF(mainDict);
		return nullptr;
	}

	Py_DECREF(mainDict);

	return localDict;
}

// Get the line where the python error occurred
int PythonScriptRuntime::getPyErrorLine() {
	INFO(Q_FUNC_INFO)
	// Python interpreter or pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return -1;

	int errorLine = -1;

	PyObject *type, *value, *traceback;

	PyErr_Fetch(&type, &value, &traceback);
	PyErr_NormalizeException(&type, &value, &traceback);

	if (traceback) {
		PyObject* p = PyObject_GetAttrString(traceback, "tb_lineno");
		if (p) {
			long line = PyLong_AsLong(p);
			if (line > INT_MIN && line <= INT_MAX)
				errorLine = static_cast<int>(line) - 1;

			Py_DECREF(p);
		}
	}

	if (errorLine == -1 && type && value && PyErr_GivenExceptionMatches(type, PyExc_SyntaxError) != -1) {
		PyObject* q = PyObject_GetAttrString(value, "lineno");
		if (q) {
			long line = PyLong_AsLong(q);
			if (line > INT_MIN && line <= INT_MAX)
				errorLine = static_cast<int>(line) - 1;

			Py_DECREF(q);
		}
	}

	PyErr_Restore(type, value, traceback);

	return errorLine;
}

bool PythonScriptRuntime::populateVariableInfo() {
	INFO(Q_FUNC_INFO)
	PyObject* items = PyDict_Items(m_localDict);
	if (!items)
		return false;

	QMap<QString, VariableInfo> variablesInfo;

	Py_ssize_t size = PyList_Size(items);

	for (Py_ssize_t i = 0; i < size; ++i) {
		PyObject* item = PySequence_GetItem(items, i);
		if (!item) {
			Py_DECREF(items);
			return false;
		}

		PyObject* keyObj = PySequence_GetItem(item, 0);
		if (!keyObj) {
			Py_DECREF(items);
			Py_DECREF(item);
			return false;
		}

		const QString& key = PythonScriptRuntime::pyUnicodeToQString(keyObj);
		if (key.isNull()) {
			Py_DECREF(items);
			Py_DECREF(item);
			Py_DECREF(keyObj);
			return false;
		}

		Py_DECREF(keyObj);

		if (key.startsWith(QStringLiteral("__"))) {
			Py_DECREF(item);
			continue;
		}

		if (QString::compare(key, QStringLiteral("project"), Qt::CaseSensitive) == 0) {
			Py_DECREF(item);
			continue;
		}

		PyObject* valueObj = PySequence_GetItem(item, 1);
		if (!valueObj) {
			Py_DECREF(items);
			Py_DECREF(item);
			return false;
		}

		if (PyModule_Check(valueObj)) {
			Py_DECREF(item);
			Py_DECREF(valueObj);
			continue;
		}

		if (PyFunction_Check(valueObj)) {
			Py_DECREF(item);
			Py_DECREF(valueObj);
			continue;
		}

		if (PyType_Check(valueObj)) {
			Py_DECREF(item);
			Py_DECREF(valueObj);
			continue;
		}

		PyObject* valueRepr = PyObject_Repr(valueObj);
		if (!valueRepr) {
			Py_DECREF(item);
			Py_DECREF(valueObj);
			Py_DECREF(items);
			return false;
		}

		Py_DECREF(item);
		Py_DECREF(valueObj);

		const QString& value = PythonScriptRuntime::pyUnicodeToQString(valueRepr);
		if (value.isNull()) {
			Py_DECREF(items);
			Py_DECREF(valueRepr);
			return false;
		}

		Py_DECREF(valueRepr);

		const QString& typeQuery = QStringLiteral("type(") + key + QStringLiteral(")");
		PyObject* typeObj = PyRun_String(typeQuery.toLocal8Bit().constData(), Py_eval_input, m_localDict, m_localDict);
		if (!typeObj) {
			Py_DECREF(items);
			return false;
		}

		PyObject* typeRepr = PyObject_Repr(typeObj);
		if (!typeRepr) {
			Py_DECREF(typeObj);
			Py_DECREF(items);
			return false;
		}

		Py_DECREF(typeObj);

		const QString& type = PythonScriptRuntime::pyUnicodeToQString(typeRepr);
		if (type.isNull()) {
			Py_DECREF(items);
			Py_DECREF(typeRepr);
			return false;
		}

		Py_DECREF(typeRepr);

		ScriptRuntime::VariableInfo variableInfo;
		variableInfo.value = value;
		variableInfo.type = type;

		variablesInfo.insert(key, variableInfo);
	}

	Py_DECREF(items);

	m_variableModel->setVariablesInfo(variablesInfo);

	return true;
}

QString PythonScriptRuntime::pyUnicodeToQString(PyObject* obj) {
	INFO(Q_FUNC_INFO)
	PyObject* bytes = PyUnicode_AsUTF8String(obj);
	if (!bytes)
		return {};

	char* charPtr = PyBytes_AsString(bytes);
	if (!charPtr) {
		Py_DECREF(bytes);
		return {};
	}

	Py_DECREF(bytes);
	return QString::fromUtf8(charPtr);
}
