#include "PythonScriptRuntime.h"
#include "PythonLogger.h"

#include <Python.h>
#include <sbkconverter.h>
#include <sbkmodule.h>

#include "backend/core/Project.h"
#include "backend/script/Script.h"
#include "backend/script/ScriptRuntime.h"
#include "pyerrors.h"
#include "pylabplot/pylabplot_python.h"

#include <codecvt>
#include <string>

// PyObject* handling:
// PySys_GetObject(), PyImport_AddModule() return a borrowed reference so we create own reference with Py_INCREF() and Py_DECREF(o) when done
// PyObject_GetAttrString(), Shiboken::Object::newObject() return a new reference

static wchar_t programName[] = L"labplot";
static wchar_t* argv[] = {programName};
static const wchar_t* pythonInterpreter = PYTHON3_EXECUTABLE; // PYTHON3_EXECUTABLE is a macro and will be replaced by the actual python executable name

// The name of our python extension module: pylabplot
static const char* moduleName = "pylabplot";

// The python extension module init function for pylabplot generated by shiboken
extern "C" PyObject* PyInit_pylabplot();

// The array of python types provided by pylabplot generated by shiboken from our C++ types
extern PyTypeObject** SbkpylabplotTypes;

// The python interpreter and pylabplot need to be only initialized once for all python scriptruntimes.
// So we used this static variable to track if it is done already
bool PythonScriptRuntime::ready{false};

// To redirect python stdout and stderr to our output in the ScriptEditor, we temporarily replace the
// sys.stdout and sys.stderr objects in python with instances of our PythonLogger class. These variables
// hold the original sys.stdout and sys.stderr objects from python.
PyObject* PythonScriptRuntime::sysStdOutWrite{nullptr};
PyObject* PythonScriptRuntime::sysStdErrWrite{nullptr};

PythonScriptRuntime::PythonScriptRuntime(Script* script)
	: ScriptRuntime(QStringLiteral("Python"), script),
	m_loggerStdOut(new PythonLogger(this, false)),
	m_loggerStdErr(new PythonLogger(this, true)) {
}

PythonScriptRuntime::~PythonScriptRuntime() {
	INFO(Q_FUNC_INFO)
	if (Py_IsInitialized()) {
		PyGILState_STATE gil = PyGILState_Ensure();
		// allow python garbage collection
		Py_XDECREF(m_localDict);

		m_loggerStdOut = nullptr;
		m_loggerStdErr = nullptr;
		m_localDict = nullptr;

		PyGILState_Release(gil);
	}

	Py_XDECREF(sysStdOutWrite);
	Py_XDECREF(sysStdErrWrite);
	sysStdOutWrite = nullptr;
	sysStdErrWrite = nullptr;

	delete m_loggerStdOut;
	delete m_loggerStdErr;
}

bool PythonScriptRuntime::init() {
	INFO(Q_FUNC_INFO)
	// initialize python interpreter and pylabplot module
	bool init = PythonScriptRuntime::initPython();
	if (!init) {
		WARN("Failed to initialize python interpreter and pylabplot module")
		return false;
	}

	// Get sys.stdout
	if (!sysStdOutWrite) {
		auto* sysStdOut = PySys_GetObject("stdout");	// borrowed reference
		if (!sysStdOut) {
			WARN("Failed to get sys.stdout")
			return false;
		}

		Py_INCREF(sysStdOut);	// own it

		sysStdOutWrite = PyObject_GetAttrString(sysStdOut, "write"); // owned reference
		if (!sysStdOutWrite) {
			WARN("Failed to get sys.stdout.write")
			Py_DECREF(sysStdOut);
			return false;
		}
	}

	// Get sys.stderr
	if (!sysStdErrWrite) {
		auto* sysStdErr = PySys_GetObject("stderr");	// borrowed reference
		if (!sysStdErr) {
			WARN("Failed to get sys.stderr")
			return false;
		}

		Py_INCREF(sysStdErr);	// own it

		sysStdErrWrite = PyObject_GetAttrString(sysStdErr, "write"); // owned reference
		if (!sysStdErrWrite) {
			WARN("Failed to get sys.stderr.write")
			Py_DECREF(sysStdErr);
			return false;
		}
	}

	// create a fresh local context where we can execute our scripts
	// to remove variables from previous runs
	m_localDict = PythonScriptRuntime::createLocalDict();
	if (!m_localDict) {
		WARN("Failed creating fresh context")
		return false;
	}

	return true;
}

bool PythonScriptRuntime::initPython() {
	INFO(Q_FUNC_INFO)
	// Python interpreter and pylabplot module is already initialized
	if (Py_IsInitialized() && ready)
		return true;

	PyConfig config;
	PyConfig_InitPythonConfig(&config);

	// TODO: use macro for converting wchar_t
	std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
	INFO(Q_FUNC_INFO << ", Python interpreter: " << converter.to_bytes(pythonInterpreter))
	PyConfig_SetString(&config, &config.program_name, pythonInterpreter);
	PyConfig_SetArgv(&config, 1, argv);

	INFO(Q_FUNC_INFO << ", CALLING PyImport_AppendInittab()")
	if (PyImport_AppendInittab(moduleName, PyInit_pylabplot) == -1) {
		WARN("Failed to add the pylabplot module to the table of built-in modules")
		return false;
	}

	Py_InitializeFromConfig(&config);
	PyConfig_Clear(&config);

	const bool pythonInitialized = PyInit_pylabplot() != nullptr;
	const bool pyErrorOccurred = PyErr_Occurred() != nullptr;
	if (!pythonInitialized || pyErrorOccurred) {
		WARN("Failed to initialize the pylabplot module")
		return false;
	}

	ready = true;
	return true;
}

bool PythonScriptRuntime::reset() {
	INFO(Q_FUNC_INFO)
	// Python interpreter and pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return false;

	// Create a fresh local context for script execution
	auto* localDict = PythonScriptRuntime::createLocalDict();
	if (!localDict) {
		WARN(Q_FUNC_INFO << ", no local dict")
		// allow python garbage collection
		Py_XDECREF(m_localDict);
		return false;
	}

	// allow python garbage collection
	Py_XDECREF(m_localDict);

	m_localDict = localDict;

	return true;
}

bool PythonScriptRuntime::cancel() {
	// Python interpreter and pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return false;

	// not yet implemented
	return false;
}

bool PythonScriptRuntime::redirectStream(const char* streamName, PythonLogger* loggerInstance) {
	INFO(Q_FUNC_INFO)
	auto* sysStream = PySys_GetObject(streamName);	// borrowed reference
	if (!sysStream) {
		WARN("Failed to get" << streamName)
		return false;
	}
	Py_INCREF(sysStream);	// own it

	auto* loggerStream = PythonScriptRuntime::shibokenConvertToPyObject(loggerInstance); // owned reference
	if (!loggerStream) {
		WARN("Failed to convert PythonLogger instance to PyObject")
		Py_DECREF(sysStream);
		return false;
	}

	INFO("HERE 3")
	auto* loggerStreamWrite = PyObject_GetAttrString(loggerStream, "write"); // new reference
	if (!loggerStreamWrite) {
		WARN("Failed to get write from loggerStream")
		Py_DECREF(sysStream);
		Py_DECREF(loggerStream);
		return false;
	}
	INFO("HERE 4")

	if (PyObject_SetAttrString(sysStream, "write", loggerStreamWrite) < 0) {
		WARN("Failed to set write from loggerStream in" << streamName)
		Py_DECREF(sysStream);
		Py_DECREF(loggerStream);
		Py_DECREF(loggerStreamWrite);
		return false;
	}
	INFO("HERE 5")
	Py_DECREF(sysStream);
	Py_DECREF(loggerStream);
	Py_DECREF(loggerStreamWrite);
	INFO("HERE 6")

	return true;
}

bool PythonScriptRuntime::redirectOutput() {
	INFO(Q_FUNC_INFO)
	if (!Py_IsInitialized() || !ready) {
		WARN(Q_FUNC_INFO << "Python interpreter or pylabplot module is not initialized")
		return false;
	}

	INFO("HERE 7")
	if (!redirectStream("stdout", m_loggerStdOut))
		return false;
	INFO("HERE 7 DONE")

	INFO("HERE 8")
	if (!redirectStream("stderr", m_loggerStdErr))
		return false;
	INFO("HERE 8 DONE")

	return true;
}

bool PythonScriptRuntime::restoreStreamWrite(PyObject* sysModule, const char* streamName, PyObject* originalWrite) {
	INFO(Q_FUNC_INFO)
	auto* stream = PyObject_GetAttrString(sysModule, streamName);	// owned
	if (!stream) {
		WARN("Failed to get " << streamName)
		return false;
	}

	INFO("HERE!")
	assert(originalWrite);
	INFO("originalWrite refcnt = " << Py_REFCNT(originalWrite));
	if (PyObject_SetAttrString(stream, "write", originalWrite) < 0) {
		WARN("Failed to restore " << streamName);
		Py_DECREF(stream);
		return false;
	}
	INFO("HERE! DONE")

	Py_DECREF(stream);
	return true;
}


bool PythonScriptRuntime::unRedirectOutput() {
	INFO(Q_FUNC_INFO)
	// Python interpreter and pylabplt module is not initialized
	if (!Py_IsInitialized() || !ready) {
		WARN(Q_FUNC_INFO << "Python interpreter or pylabplot module is not initialized")
		return false;
	}

	PyGILState_STATE gil = PyGILState_Ensure();
	bool ok = true;

	auto* sysModule = PyImport_ImportModule("sys");	// new reference
	if (!sysModule) {
		WARN(Q_FUNC_INFO << "Failed loading sys module")
		PyGILState_Release(gil);
		return false;
	}

	if (sysStdOutWrite)
		ok &= restoreStreamWrite(sysModule, "stdout", sysStdOutWrite);
	if (sysStdErrWrite)
		ok &= restoreStreamWrite(sysModule, "stderr", sysStdErrWrite);

	INFO("HERE2")
	Py_DECREF(sysModule);
	INFO("HERE2 DONE")
	PyGILState_Release(gil);
	return ok;
}

bool PythonScriptRuntime::exec(const QString& code) {
	INFO(Q_FUNC_INFO)
	// Python interpreter or pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return false;

	PyGILState_STATE gil = PyGILState_Ensure();

	if (!reset()) {
		WARN(Q_FUNC_INFO <<", Failed to create new local context for script execution")
		PyGILState_Release(gil);
		return false;
	}

	if (!m_localDict) {
		WARN(Q_FUNC_INFO << ", Failed to create new local context for script execution")
		PyGILState_Release(gil);
		return false;
	}

	// Redirect python output to output in our ScriptEditor
	if (!redirectOutput()) {
		WARN(Q_FUNC_INFO << ", Redirect python output to output in our ScriptEditor")
		PyGILState_Release(gil);
		return false;
	}

	// Clear any previous errors in the python interpreter
	PyErr_Clear();

	// Compile script to python bytecode
	auto* compiled = Py_CompileString(qPrintable(code), qPrintable(m_name), Py_file_input);	// new reference
	if (!compiled) {
		if (PyErr_Occurred()) {
			m_errorLine = PythonScriptRuntime::getPyErrorLine(); // Get the line where the error occurred
			PyErr_Print(); // Print the error to our output in ScriptEditor
			PyGILState_Release(gil);
			return true; // This is ok
		}
		PyGILState_Release(gil);
		return false;
	}

	// Clear any previous errors in the python interpreter
	PyErr_Clear();

	// Evaluate the python bytecode
	auto* res = PyEval_EvalCode(compiled, m_localDict, m_localDict);
	if (!res) {
		Py_DECREF(compiled);
		if (PyErr_Occurred()) {
			m_errorLine = PythonScriptRuntime::getPyErrorLine(); // Get the line where the error occurred
			PyErr_Print(); // Print the error to our output in ScriptEditor
			PyGILState_Release(gil);
			return true; // this is ok
		}
		PyGILState_Release(gil);
		return false;
	}

	Py_DECREF(compiled);
	Py_DECREF(res);

	// Unredirect python output to output in our ScriptEditor
	if (!unRedirectOutput()) {
		WARN("Unredirect python output failed")
		PyGILState_Release(gil);
		return false;
	}

	// fetch new variables
	if (!populateVariableInfo()) {
		WARN("fetch new variables failed")
		PyGILState_Release(gil);
		return false;
	}

	return true;
}

PyTypeObject* PythonScriptRuntime::getPythonLoggerType() {
	INFO(Q_FUNC_INFO)
	static PyTypeObject* cachedType = nullptr;
	if (cachedType)
		return cachedType;

	// import binding module (mandatory for Qt 6.10)
	auto* module = PyImport_ImportModule("pylabplot");
	if (!module) {
		WARN("Importing module pylabplot failed!")
		return nullptr;
	}

	Py_DECREF(module);

	cachedType = Shiboken::SbkType<::PythonLogger>();

	return cachedType;
}

// Converts a C++ object to a PyObject (owned reference)
PyObject* PythonScriptRuntime::shibokenConvertToPyObject(PythonLogger* object) {
	INFO(Q_FUNC_INFO)
	if (!Py_IsInitialized() || !ready)
		return nullptr;

	auto* loggerObject = getPythonLoggerType();
	if (!loggerObject) {
		WARN("Failed to get Python type for PythonLogger")
		return nullptr;
	}

	INFO("Creating a Python wrapper object for the C++ instance ..")
	auto* po = Shiboken::Object::newObject(loggerObject, object);
	INFO("	DONE")

	return po;
}

// Returns the dictionary which contains the variables in module 'name'
// returns owned reference
PyObject* PythonScriptRuntime::getModuleDict(const QString& name) {
	INFO(Q_FUNC_INFO)
	// Python interpreter or pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return nullptr;

	auto* module = PyImport_AddModule(qPrintable(name));	// borrowed reference
	if (!module) {
		WARN(Q_FUNC_INFO << "Failed to locate module " << name.toStdString())
		return nullptr;
	}

	Py_INCREF(module);	// own it

	auto* moduleDict = PyModule_GetDict(module);	// borrowed reference
	if (!moduleDict) { 
		WARN(Q_FUNC_INFO << "Failed to get module __dict__")
		Py_DECREF(module);
		return nullptr;
	}

	Py_INCREF(moduleDict);
	Py_DECREF(module);	// unown it

	return moduleDict;
}

// Creates a new local context for the execution of our script
// The process creates a dictionary and copy over the python builtins from the main module
// returns owned reference
PyObject* PythonScriptRuntime::createLocalDict() {
	INFO(Q_FUNC_INFO)
	// Python interpreter or pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return nullptr;

	auto* mainDict = PythonScriptRuntime::getModuleDict(QStringLiteral("__main__"));	// owned reference
	if (!mainDict) {
		WARN(Q_FUNC_INFO << "Failed to get main dict")
		return nullptr;
	}

	// create a dictionary
	auto* localDict = PyDict_New();	// owned
	if (!localDict) {
		Py_DECREF(mainDict);	// unown it
		return nullptr;
	}

	// copy python builtins to the dictionary
	if (PyDict_SetItemString(localDict, "__builtins__", PyDict_GetItemString(mainDict, "__builtins__")) < 0) {
		Py_DECREF(localDict);
		Py_DECREF(mainDict);
		return nullptr;
	}

	Py_DECREF(mainDict);

	return localDict;
}

// Get the line where the python error occurred
int PythonScriptRuntime::getPyErrorLine() {
	INFO(Q_FUNC_INFO)
	// Python interpreter or pylabplot module is not initialized
	if (!Py_IsInitialized() || !ready)
		return -1;

	int errorLine = -1;

	PyObject *type, *value, *traceback;

	PyErr_Fetch(&type, &value, &traceback);
	PyErr_NormalizeException(&type, &value, &traceback);

	if (traceback) {
		auto* p = PyObject_GetAttrString(traceback, "tb_lineno");	// owned
		if (p) {
			long line = PyLong_AsLong(p);
			if (line > INT_MIN && line <= INT_MAX)
				errorLine = static_cast<int>(line) - 1;

			Py_DECREF(p);
		}
	}

	if (errorLine == -1 && type && value && PyErr_GivenExceptionMatches(type, PyExc_SyntaxError) != -1) {
		auto* p = PyObject_GetAttrString(value, "lineno");	// owned
		if (p) {
			long line = PyLong_AsLong(p);
			if (line > INT_MIN && line <= INT_MAX)
				errorLine = static_cast<int>(line) - 1;

			Py_DECREF(p);
		}
	}

	PyErr_Restore(type, value, traceback);

	return errorLine;
}

bool PythonScriptRuntime::populateVariableInfo() {
	INFO(Q_FUNC_INFO)
	auto* items = PyDict_Items(m_localDict);
	if (!items)
		return false;

	QMap<QString, VariableInfo> variablesInfo;

	auto size = PyList_Size(items);

	for (Py_ssize_t i = 0; i < size; ++i) {
		auto* item = PySequence_GetItem(items, i);
		if (!item) {
			Py_DECREF(items);
			return false;
		}

		auto* keyObj = PySequence_GetItem(item, 0);
		if (!keyObj) {
			Py_DECREF(items);
			Py_DECREF(item);
			return false;
		}

		const QString& key = PythonScriptRuntime::pyUnicodeToQString(keyObj);	//TODO
		if (key.isNull()) {
			Py_DECREF(items);
			Py_DECREF(item);
			Py_DECREF(keyObj);
			return false;
		}

		Py_DECREF(keyObj);

		if (key.startsWith(QStringLiteral("__"))) {
			Py_DECREF(item);
			continue;
		}

		if (QString::compare(key, QStringLiteral("project"), Qt::CaseSensitive) == 0) {
			Py_DECREF(item);
			continue;
		}

		auto* valueObj = PySequence_GetItem(item, 1);
		if (!valueObj) {
			Py_DECREF(items);
			Py_DECREF(item);
			return false;
		}

		if (PyModule_Check(valueObj)) {
			Py_DECREF(item);
			Py_DECREF(valueObj);
			continue;
		}

		if (PyFunction_Check(valueObj)) {
			Py_DECREF(item);
			Py_DECREF(valueObj);
			continue;
		}

		if (PyType_Check(valueObj)) {
			Py_DECREF(item);
			Py_DECREF(valueObj);
			continue;
		}

		auto* valueRepr = PyObject_Repr(valueObj);
		if (!valueRepr) {
			Py_DECREF(item);
			Py_DECREF(valueObj);
			Py_DECREF(items);
			return false;
		}

		Py_DECREF(item);
		Py_DECREF(valueObj);

		const QString& value = PythonScriptRuntime::pyUnicodeToQString(valueRepr);
		if (value.isNull()) {
			Py_DECREF(items);
			Py_DECREF(valueRepr);
			return false;
		}

		Py_DECREF(valueRepr);

		const QString& typeQuery = QStringLiteral("type(") + key + QStringLiteral(")");
		auto* typeObj = PyRun_String(qPrintable(typeQuery), Py_eval_input, m_localDict, m_localDict);
		if (!typeObj) {
			Py_DECREF(items);
			return false;
		}

		auto* typeRepr = PyObject_Repr(typeObj);
		if (!typeRepr) {
			Py_DECREF(typeObj);
			Py_DECREF(items);
			return false;
		}

		Py_DECREF(typeObj);

		const QString& type = PythonScriptRuntime::pyUnicodeToQString(typeRepr);
		if (type.isNull()) {
			Py_DECREF(items);
			Py_DECREF(typeRepr);
			return false;
		}

		Py_DECREF(typeRepr);

		ScriptRuntime::VariableInfo variableInfo;
		variableInfo.value = value;
		variableInfo.type = type;

		variablesInfo.insert(key, variableInfo);
	}

	Py_DECREF(items);

	m_variableModel->setVariablesInfo(variablesInfo);

	return true;
}

QString PythonScriptRuntime::pyUnicodeToQString(PyObject* obj) {
	auto* bytes = PyUnicode_AsUTF8String(obj);
	if (!bytes)
		return {};

	char* charPtr = PyBytes_AsString(bytes);
	if (!charPtr) {
		Py_DECREF(bytes);
		return {};
	}

	Py_DECREF(bytes);
	return QString::fromUtf8(charPtr);
}
