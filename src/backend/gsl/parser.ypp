/*
    File                 : parser.ypp
    Project              : LabPlot
    Description          : Parser for mathematical expressions
    --------------------------------------------------------------------
    SPDX-FileCopyrightText: 2014 Alexander Semke <alexander.semke@web.de>
    SPDX-FileCopyrightText: 2014-2020 Stefan Gerlach <stefan.gerlach@uni.kn>
    SPDX-License-Identifier: GPL-2.0-or-later
*/

%{
#include <cstring>
#include <cctype>
#include <cstdlib>
#include <clocale>
#include <cmath>
#include <vector>
#include <memory>
#include <sstream>
#include <iostream>
#include <charconv>
#ifdef HAVE_XLOCALE
#include <xlocale.h>
#endif
#include "Parser.h"
#include "parser.h"
#include "parser_private.h"
#include "constants.h"
#include "functions.h"
#if defined(_WIN32)
#define locale_t _locale_t
#define strtod_l _strtod_l
#define freelocale _free_locale
#endif

#include <gsl/gsl_sf_gamma.h>
#define YYERROR_VERBOSE 1
%}

%union {
double dval;	/* For returning numbers */
Parsing::BaseSymbol* tptr;   /* For returning symbol-table pointers */
}

%{

namespace Parsing {
	struct param;
        int yylex(YYSTYPE* yyval, param *p);
} // Parser

namespace {
	double res;

        static void wrongArgumentNumberMessage(Parsing::param* p, const std::string_view& function_name, int provided, int expected) {
                std::stringstream ss;
                ss << "Internal parsing Error: Wrong argument count for '" << function_name << "'. Provided: " << provided << ", Expected: " << expected;
                p->parser->setLastErrorMessage(ss.str());
	}

        static void wrongArgumentInternalErrorMessage(Parsing::param* p, const std::string_view& function_name, int expected) {
                std::stringstream ss;
                ss << "Internal parsing Error: Wrong argument count for '" << function_name << "'. Expected: " << expected << ", but function does not have this number of arguments";
                p->parser->setLastErrorMessage(ss.str());
        }

        static void notImplementedError(Parsing::param* p, const std::string_view& function_name) {
                std::stringstream ss;
                ss << "Parsing Error: '" << function_name << "' not implemented.";
                p->parser->setLastErrorMessage(ss.str());
	}

        static void yyerrorFunction(Parsing::param* p, const std::string_view& function_name, const char* msg) {
                std::stringstream ss;
                ss << "Parsing Error: In function '" << function_name << "': " << msg;
                p->parser->setLastErrorMessage(ss.str());
	}

        void yyerror(Parsing::param* p, const char* msg) {
                std::stringstream ss;
                ss << "Parsing Error: " << msg;
                p->parser->setLastErrorMessage(ss.str());
	}
} // anonymous namespace

%}

%define api.pure full

%lex-param {Parsing::param *p}
%parse-param {Parsing::param *p}

%token <dval>  NUM 	/* Simple double precision number */
%token <tptr> VAR FNCT SPECFNCT /* VARiable and FuNCTion and Special functions*/
/* https://www.gnu.org/software/bison/manual/html_node/Token-Decl.html */
%token <operator> OR "||"
%token <operator> AND "&&"
%token <operator> LE "<="
%token <operator> GE ">="
%type  <dval>  expr

%right '='
%left '-' '+' OR LE GE '<' '>'
%left '*' '/' '%' AND
%left NEG     /* Negation--unary minus */
%right '^' '!'

%%
input:   /* empty */
	| input line
;

line:	'\n'
        | expr '\n'   { p->result = $1; }
	| error '\n' { yyerrok; }
;

expr:      NUM       { $$ = $1;                            }
| VAR                { $$ = std::get<double>($1->value); p->variablesCounter++;}
| VAR '=' expr       { $$ = std::get<double>($1->value) = $3; p->variablesCounter++;       }
| SPECFNCT '(' ')'       {
							const auto& special_function = std::get<Parsing::special_function_def>($1->value);
							if (!special_function.payload.expired() && !special_function.payload.lock()->constant)
                                                                p->variablesCounter++;
							const int argc = special_function.funsptr->argc;
							if (argc != 0) {
                                                                wrongArgumentNumberMessage(p, $1->name, argc, 0);
                                                                p->errorCount++;
								return 1;
							}
							try {
								const auto function = std::get<Parsing::func_tPayload>(special_function.funsptr->fnct);
                                                                if (!p->parser->skipSpecialFunctionEvaluation()) {
									if (function == nullptr) {
                                                                                notImplementedError(p, $1->name);
                                                                                p->errorCount++;
										return 2;
									}
									$$ = function(special_function.payload);
								} else
									$$ = std::nan("0");
							} catch (const std::bad_variant_access& ex) {
                                                                wrongArgumentInternalErrorMessage(p, $1->name, 0);
                                                                p->errorCount++;
								return 1;
							}
						}
| SPECFNCT '(' VAR ')'  {
							const auto& special_function = std::get<Parsing::special_function_def>($1->value);
							if (!special_function.payload.expired() && !special_function.payload.lock()->constant)
                                                                p->variablesCounter++;
							const int argc = special_function.funsptr->argc;
							if (argc != 1) {
                                                                wrongArgumentNumberMessage(p, $1->name, argc, 1);
                                                                p->errorCount++;
								return 1;
							}
							try {
                                                                const auto function = std::get<Parsing::func_tVariablePayload>(special_function.funsptr->fnct);
                                                                if (!p->parser->skipSpecialFunctionEvaluation()) {
									if (function == nullptr) {
                                                                                notImplementedError(p, $1->name);
                                                                                p->errorCount++;
										return 2;
									}
									$$ = function($3->name, special_function.payload);
								} else
									$$ = std::nan("0");
							} catch (const std::bad_variant_access& ex) {
                                                                wrongArgumentInternalErrorMessage(p, $1->name, 1);
                                                                p->errorCount++;
								return 1;
							}
						}
| SPECFNCT '(' expr ')'  {
                                                    const auto& special_function = std::get<Parsing::special_function_def>($1->value);
                                                    if (!special_function.payload.expired() && !special_function.payload.lock()->constant)
                                                            p->variablesCounter++;
                                                    const int argc = special_function.funsptr->argc;
                                                    if (argc != 1) {
                                                            wrongArgumentNumberMessage(p, $1->name, argc, 1);
                                                            p->errorCount++;
                                                            return 1;
                                                    }
                                                    try {
                                                            const auto function = std::get<Parsing::func_tValuePayload>(special_function.funsptr->fnct);
                                                            if (!p->parser->skipSpecialFunctionEvaluation()) {
                                                                    if (function == nullptr) {
                                                                            notImplementedError(p, $1->name);
                                                                            p->errorCount++;
                                                                            return 2;
                                                                    }
                                                                    $$ = function($3, special_function.payload);
                                                            } else
                                                                    $$ = std::nan("0");
                                                    } catch (const std::bad_variant_access& ex) {
                                                            wrongArgumentInternalErrorMessage(p, $1->name, 1);
                                                            p->errorCount++;
                                                            return 1;
                                                    }
                                            }
| SPECFNCT '(' expr ';' expr ')'  {
                                                    const auto& special_function = std::get<Parsing::special_function_def>($1->value);
                                                    if (!special_function.payload.expired() && !special_function.payload.lock()->constant)
                                                            p->variablesCounter++;
                                                    const int argc = special_function.funsptr->argc;
                                                    if (argc != 2) {
                                                            wrongArgumentNumberMessage(p, $1->name, argc, 2);
                                                            p->errorCount++;
                                                            return 1;
                                                    }
                                                    try {
                                                            const auto function = std::get<Parsing::func_t2ValuePayload>(special_function.funsptr->fnct);
                                                            if (!p->parser->skipSpecialFunctionEvaluation()) {
                                                                    if (function == nullptr) {
                                                                            notImplementedError(p, $1->name);
                                                                            p->errorCount++;
                                                                            return 2;
                                                                    }
                                                                    $$ = function($3, $5, special_function.payload);
                                                            } else
                                                                    $$ = std::nan("0");
                                                    } catch (const std::bad_variant_access& ex) {
                                                            wrongArgumentInternalErrorMessage(p, $1->name, 1);
                                                            p->errorCount++;
                                                            return 1;
                                                    }
                                            }
| SPECFNCT '(' expr ';' VAR ')'  {
                                                                        const auto& special_function = std::get<Parsing::special_function_def>($1->value);
                                                                        if (!special_function.payload.expired() && !special_function.payload.lock()->constant)
                                                                                p->variablesCounter++;
                                                                        const int argc = special_function.funsptr->argc;
                                                                        if (argc != 2) {
                                                                                wrongArgumentNumberMessage(p, $1->name, argc, 2);
                                                                                p->errorCount++;
                                                                                return 1;
                                                                        }
                                                                        try {
                                                                                const auto function = std::get<Parsing::func_tValueVariablePayload>(special_function.funsptr->fnct);
                                                                                if (!p->parser->skipSpecialFunctionEvaluation()) {
                                                                                        if (function == nullptr) {
                                                                                                notImplementedError(p, $1->name);
                                                                                                p->errorCount++;
                                                                                                return 2;
                                                                                        }
                                                                                        $$ = function($3 ,$5->name, special_function.payload);
                                                                                } else
                                                                                        $$ = std::nan("0");
                                                                        } catch (const std::bad_variant_access& ex) {
                                                                                wrongArgumentInternalErrorMessage(p, $1->name, 2);
                                                                                p->errorCount++;
                                                                                return 1;
                                                                        }
                                                                  }
| SPECFNCT '(' expr ';' expr ';' VAR ')'  {
                                                                                        const auto& special_function = std::get<Parsing::special_function_def>($1->value);
                                                                                        if (!special_function.payload.expired() && !special_function.payload.lock()->constant)
                                                                                                p->variablesCounter++;
                                                                                        const int argc = special_function.funsptr->argc;
                                                                                        if (argc != 3) {
                                                                                                wrongArgumentNumberMessage(p, $1->name, argc, 3);
                                                                                                p->errorCount++;
                                                                                                return 1;
                                                                                        }
                                                                                        try {
                                                                                                const auto function = std::get<Parsing::func_t2ValueVariablePayload>(special_function.funsptr->fnct);
                                                                                                if (!p->parser->skipSpecialFunctionEvaluation()) {
                                                                                                        if (function == nullptr) {
                                                                                                                notImplementedError(p, $1->name);
                                                                                                                p->errorCount++;
                                                                                                                return 2;
                                                                                                        }
                                                                                                        $$ = function($3, $5, $7->name, special_function.payload);
                                                                                                } else
                                                                                                        $$ = std::nan("0");
                                                                                        } catch (const std::bad_variant_access& ex) {
                                                                                                wrongArgumentInternalErrorMessage(p, $1->name, 3);
                                                                                                p->errorCount++;
                                                                                                return 1;
                                                                                        }
                                                                                  }
| SPECFNCT '(' expr ';' expr ';' expr ';' VAR ')'  {
													const auto& special_function = std::get<Parsing::special_function_def>($1->value);
													if (!special_function.payload.expired() && !special_function.payload.lock()->constant)
                                                                                                                p->variablesCounter++;
													const int argc = special_function.funsptr->argc;
													if (argc != 4) {
                                                                                                                wrongArgumentNumberMessage(p, $1->name, argc, 4);
                                                                                                                p->errorCount++;
														return 1;
													}
													try {
                                                                                                                const auto function = std::get<Parsing::func_t3ValueVariablePayload>(special_function.funsptr->fnct);
                                                                                                                if (!p->parser->skipSpecialFunctionEvaluation()) {
															if (function == nullptr) {
                                                                                                                                notImplementedError(p, $1->name);
                                                                                                                                p->errorCount++;
																return 2;
															}
															$$ = function($3, $5, $7, $9->name, special_function.payload);
														} else
															$$ = std::nan("0");
													} catch (const std::bad_variant_access& ex) {
                                                                                                                wrongArgumentInternalErrorMessage(p, $1->name, 4);
                                                                                                                p->errorCount++;
														return 1;
													}


												  }
| SPECFNCT '(' expr ')'  { p->errorCount++; yyerrorFunction(p, $1->name, "Argument must be a variable not an expression");}
| SPECFNCT '(' expr ';' expr ')'   { p->errorCount++; yyerrorFunction(p, $1->name, "Last argument must be a variable not an expression");}
| SPECFNCT '(' expr ';' expr ';' expr ')'  { p->errorCount++; yyerrorFunction(p, $1->name, "Last argument must be a variable not an expression");}
| SPECFNCT '(' expr ';' expr ';' expr ';' expr ')'  { p->errorCount++; yyerrorFunction(p, $1->name, "Last argument must be a variable not an expression");}
| FNCT '(' ')'       {
						const auto* function = std::get<Parsing::funs*>($1->value);
						const int argc = function->argc;
						if (argc != 0) {
                                                        wrongArgumentNumberMessage(p, $1->name, argc, 0);
                                                        p->errorCount++;
							return 1;
						} else {
							try {
								const auto fnct_ptr = std::get<Parsing::func_t>(function->fnct);
								$$ = fnct_ptr();
							} catch (const std::bad_variant_access& ex) {
                                                                wrongArgumentInternalErrorMessage(p, $1->name, 0);
                                                                p->errorCount++;
								return 1;
							}
						}
					}
| FNCT '(' expr ')'  {
						const auto* function = std::get<Parsing::funs*>($1->value);
						const int argc = function->argc;
						if (argc != 1) {
                                                        wrongArgumentNumberMessage(p, $1->name, argc, 1);
                                                        p->errorCount++;
							return 1;
						} else {
							try {
								const auto fnct_ptr = std::get<Parsing::func_t1>(function->fnct);
								$$ = fnct_ptr($3);
							} catch (const std::bad_variant_access& ex) {
                                                                wrongArgumentInternalErrorMessage(p, $1->name, 1);
                                                                p->errorCount++;
								return 1;
							}
						}
					}
| FNCT '(' expr ',' expr ')'  {
								const auto* function = std::get<Parsing::funs*>($1->value);
								const int argc = function->argc;
								if (argc != 2) {
                                                                        wrongArgumentNumberMessage(p, $1->name, argc, 2);
                                                                        p->errorCount++;
									return 1;
								} else {
									try {
										const auto fnct_ptr = std::get<Parsing::func_t2>(function->fnct);
										$$ = fnct_ptr($3,$5);
									} catch (const std::bad_variant_access& ex) {
                                                                                wrongArgumentInternalErrorMessage(p, $1->name, 2);
                                                                                p->errorCount++;
										return 1;
									}
								}
							}
| FNCT '(' expr ',' expr ',' expr ')'  {
										const auto* function = std::get<Parsing::funs*>($1->value);
										const int argc = function->argc;
										if (argc != 3) {
                                                                                        wrongArgumentNumberMessage(p, $1->name, argc, 3);
                                                                                        p->errorCount++;
											return 1;
										} else {
											try {
												const auto fnct_ptr = std::get<Parsing::func_t3>(function->fnct);
												$$ = fnct_ptr($3,$5,$7);
											} catch (const std::bad_variant_access& ex) {
                                                                                                wrongArgumentInternalErrorMessage(p, $1->name, 3);
                                                                                                p->errorCount++;
												return 1;
											}
										}
									}
| FNCT '(' expr ',' expr ',' expr ',' expr ')'  {
													const auto* function = std::get<Parsing::funs*>($1->value);
													const int argc = function->argc;
													if (argc != 4) {
                                                                                                                wrongArgumentNumberMessage(p, $1->name, argc, 4);
                                                                                                                p->errorCount++;
														return 1;
													} else {
														try {
															const auto fnct_ptr = std::get<Parsing::func_t4>(function->fnct);
															$$ = fnct_ptr($3,$5,$7,$9);
														} catch (const std::bad_variant_access& ex) {
                                                                                                                        wrongArgumentInternalErrorMessage(p, $1->name, 4);
                                                                                                                        p->errorCount++;
															return 1;
														}
													}
												}
| FNCT '(' expr ';' expr ')'  {
								const auto* function = std::get<Parsing::funs*>($1->value);
								const int argc = function->argc;
								if (argc != 2) {
                                                                        wrongArgumentNumberMessage(p, $1->name, argc, 2);
                                                                        p->errorCount++;
									return 1;
								} else {
									try {
										const auto fnct_ptr = std::get<Parsing::func_t2>(function->fnct);
										$$ = fnct_ptr($3,$5);
									} catch (const std::bad_variant_access& ex) {
                                                                                wrongArgumentInternalErrorMessage(p, $1->name, 2);
                                                                                p->errorCount++;
										return 1;
									}
								}
							}
| FNCT '(' expr ';' expr ';' expr ')'  {
										const auto* function = std::get<Parsing::funs*>($1->value);
										const int argc = function->argc;
										if (argc != 3) {
                                                                                        wrongArgumentNumberMessage(p, $1->name, argc, 3);
                                                                                        p->errorCount++;
											return 1;
										} else {
											try {
												const auto fnct_ptr = std::get<Parsing::func_t3>(function->fnct);
												$$ = fnct_ptr($3,$5,$7);
											} catch (const std::bad_variant_access& ex) {
                                                                                                wrongArgumentInternalErrorMessage(p, $1->name, 3);
                                                                                                p->errorCount++;
												return 1;
											}
										}
									}
| FNCT '(' expr ';' expr ';' expr ';' expr ')'  {
													const auto* function = std::get<Parsing::funs*>($1->value);
													const int argc = function->argc;
													if (argc != 4) {
                                                                                                                wrongArgumentNumberMessage(p, $1->name, argc, 4);
                                                                                                                p->errorCount++;
														return 1;
													} else {
														try {
															const auto fnct_ptr = std::get<Parsing::func_t4>(function->fnct);
															$$ = fnct_ptr($3,$5,$7,$9);
														} catch (const std::bad_variant_access& ex) {
                                                                                                                        wrongArgumentInternalErrorMessage(p, $1->name, 4);
                                                                                                                        p->errorCount++;
															return 1;
														}
													}
												}
| FNCT '(' expr ';' expr ';' expr ';' expr ';' expr ')'  {
													const auto* function = std::get<Parsing::funs*>($1->value);
													const int argc = function->argc;
													if (argc != 5) {
                                                                                                                wrongArgumentNumberMessage(p, $1->name, argc, 5);
                                                                                                                p->errorCount++;
														return 1;
													} else {
														try {
															const auto fnct_ptr = std::get<Parsing::func_t5>(function->fnct);
															$$ = fnct_ptr($3,$5,$7,$9,$11);
														} catch (const std::bad_variant_access& ex) {
                                                                                                                        wrongArgumentInternalErrorMessage(p, $1->name, 5);
                                                                                                                        p->errorCount++;
															return 1;
														}
													}
}
| expr '+' expr      { $$ = $1 + $3;                          }
| expr '-' expr      { $$ = $1 - $3;                          }
| expr OR expr       { $$ = Parsing::orFunction($1, $3);       }
| expr '*' expr      { $$ = $1 * $3;                          }
| expr '/' expr      { $$ = $1 / $3;                          }
| expr '%' expr      { $$ = (int)($1) % (int)($3);            }
| expr AND expr      { $$ = Parsing::andFunction($1, $3);      }
| '!' expr           { $$ = Parsing::notFunction($2);          }
| expr GE expr       { $$ = Parsing::greaterEqualThan($1, $3); }
| expr LE expr       { $$ = Parsing::lessEqualThan($1, $3);    }
| expr '>' expr      { $$ = Parsing::greaterThan($1, $3);      }
| expr '<' expr      { $$ = Parsing::lessThan($1, $3);         }
| '-' expr  %prec NEG{ $$ = -$2;                              }
| expr '^' expr      { $$ = std::pow($1, $3);                 }
| expr '*' '*' expr  { $$ = std::pow($1, $4);                 }
| '(' expr ')'       { $$ = $2;                               }
| '|' expr '|'       { $$ = std::abs($2);                     }
| expr '!'           { $$ = gsl_sf_fact((unsigned int)$1);    }
;

%%

namespace Parsing {
	/* Static symbols like the functions ans variables in functions.cpp and constants.cpp */
	std::vector<StaticSymbol*> static_symbols;
	/* Special functions and others */
        std::vector<Symbol*> variable_symbols;

        void init_static_symbols();

        /* add new symbol with value or just set value if symbol is a variable */
        BaseSymbol* Parser::assign_symbol(const char* symbol_name, double value) {
                DEBUG_PARSER("PARSER: assign_symbol() : symbol_name = '" << symbol_name << "', value = " << value);

                BaseSymbol* ptr = nullptr;
                if (mUsedSymbolsStateMachine == UsedSymbols::No || mUsedSymbolsStateMachine == UsedSymbols::Initialize) {
                        /* be sure that the symbol table has been initialized */
                        if (variable_symbols.empty() || static_symbols.empty()) {
                                init_table();
                        }

                        ptr = get_variable_symbol(symbol_name);
                        if (!ptr) {
                                DEBUG_PARSER("PARSER: calling putsymbol(): symbol_name = '" << symbol_name << "'");
                                ptr = put_symbol(symbol_name, VAR);
                        } else {
                                DEBUG_PARSER("PARSER: Symbol already assigned\n");
                        }
                } else {
                        ptr = get_used_symbol(symbol_name);
                        if (!ptr) {
                                // The symbol was not used in the initialize phase, so we don't need it now
                                return nullptr;
                        }
                }

                /* do not assign value if symbol already exits as function */
                if (ptr->type == VAR)
                        ptr->value = value;

                return ptr;
        }

        /* save symbol in symbol table (at start of linked list) */
        Symbol* put_symbol(const char *symbol_name, int symbol_type) {
                /*	DEBUG_PARSER("PARSER: put_symbol(): symbol_name = '%s'\n", symbol_name); */

                auto* ptr = new Symbol(symbol_name, strlen(symbol_name), symbol_type);
                assert(ptr);
                switch (symbol_type) {
                case VAR: ptr->value = 0.; break;
                case FNCT: ptr->value = nullptr; break;
                case SPECFNCT: {
                        special_function_def sfp;
                        ptr->value = sfp;
                        break;
                }
                }

                variable_symbols.push_back(ptr);

                /*	DEBUG_PARSER("PARSER: put_symbol() DONE\n"); */
                return ptr;
        }

        /* remove symbol of name symbol_name from symbol table
        removes only variables of value 0
        returns 0 on success */
        int remove_symbol_(const char *symbol_name) {

                           // Only possible on variable symbols
                for (auto it = variable_symbols.begin(); it < variable_symbols.end(); it++) {
                        auto* symbol = *it;
                        if (symbol->name == symbol_name) {
                                if (symbol->type == VAR && std::get<double>(symbol->value) == 0) {
                                        DEBUG_PARSER("PARSER: REMOVING symbol '" << symbol_name << "'");
                                        variable_symbols.erase(it);
                                        delete symbol;
                                        return 0;
                                } else
                                        return 1;
                        }
                }
                return 1;
        }

        /* initialize symbol table with all known functions and constants */
        void init_table(void) {
                DEBUG_PARSER("PARSER: init_table()\n");

                if (static_symbols.empty()) {
                        // Only once neccessary
                        init_static_symbols();
                }

                           // Must be done every time to reinit
                clear_variable_symbols();
                variable_symbols.reserve(_number_specialfunctions);

                /* add special functions */
                for (int i = 0; i < _number_specialfunctions; i++) {
                        special_function_def sfd;
                        sfd.funsptr = &_special_functions[i];
                        variable_symbols.push_back(new Symbol(_special_functions[i].name, strlen(_special_functions[i].name), SPECFNCT, sfd));
                }

//                DEBUG_PARSER("PARSER: init_table() DONE. sym_table = " << ptr);
        }

        void init_static_symbols() {
                clear_static_symbols();
                static_symbols.reserve(_number_functions + _number_constants);
                for (int i = 0; i < _number_functions; i++) {
                        static_symbols.push_back(new StaticSymbol(_functions[i].name, FNCT, &_functions[i]));
                }

                /* add constants */
                for (int i = 0; i < _number_constants; i++) {
                        static_symbols.push_back(new StaticSymbol(_constants[i].name, VAR, _constants[i].value));
                }
        }

        int getcharstr(param *p) {
                DEBUG_PARSER(" getcharstr() pos = " << (int)(p->pos));

                if (p->pos >= p->string.size())
                        return EOF;
                /* DEBUG_PARSER("PARSER: 	char is %c\n", p->string[p->pos]); */
                return p->string[(p->pos)++];
        }

        void ungetcstr(size_t *pos) {
                /* DEBUG_PARSER("PARSER: ungetcstr()\n"); */
                if (*pos > 0)
                        (*pos)--;
        }

        int yylex(YYSTYPE* yyval, param *p) {
                DEBUG_PARSER("PARSER: YYLEX()");

		/* get char and skip white space */
		int c;
		while ((c = getcharstr(p)) == ' ' || c == '\t');

		/* finish if reached EOF */
		if (c == EOF) {
                        DEBUG_PARSER("PARSER: FINISHED\n");
			return 0;
		}
		/* check for non-ASCII chars */
		if (!isascii(c)) {
                        DEBUG_PARSER(" non-ASCII character found. Giving up\n");
//			p->errorCount++;
			return 0;
		}
		if (c == '\n') {
                        DEBUG_PARSER("PARSER: Reached EOL\n");
			return c;
		}

		if (c == '&') {
			// Check if the next is also an &, because then it is the AND operator
			if (getcharstr(p) == '&') {
				return AND;
			}
			ungetcstr(&(p->pos));
		} else if (c == '|') {
			if (getcharstr(p) == '|') {
				return OR;
			}
			ungetcstr(&(p->pos));
		} else if (c == '>') {
			if (getcharstr(p) == '=') {	// >=
				return GE;
			}
			ungetcstr(&(p->pos));
		} else if (c == '<') {
			if (getcharstr(p) == '=') {	// <=
				return LE;
			}
			ungetcstr(&(p->pos));
		}

                DEBUG_PARSER("PARSER: PROCESSING character '" << c << "'");

		/* process numbers */
		if (isdigit(c)) {
                        DEBUG_PARSER("PARSER: Found NUMBER (starts with digit)\n");
			ungetcstr(&(p->pos));
                        auto s = p->string.substr(p->pos);

			/* convert to double */
                        const char *remain;
	#if defined(_WIN32)
			locale_t locale = _create_locale(LC_NUMERIC, p->locale);
			if (locale == NULL) {
                                //DEBUG_PARSER("PARSER ERROR in newlocale(%s): %s. Trying system locale.\n", p->locale, strerror(errno));
				locale = _create_locale(LC_NUMERIC, "");
			}
	#else
			locale_t locale = newlocale(LC_NUMERIC_MASK, p->locale, (locale_t)nullptr);
			if (locale == (locale_t)nullptr) {
                                //pdebug("PARSER ERROR in newlocale(%s): %s. Trying system locale.\n", p->locale, strerror(errno));
				locale = newlocale(LC_NUMERIC_MASK, "", (locale_t)nullptr);
                                //pdebug("PARSER:		Reading: '%s' with system locale\n", s);
			} else {
                                //pdebug("PARSER:		Reading: '%s' with locale %s\n", s, p->locale);
			}
	#endif
			double result;
			if (locale != nullptr) {
                                auto res = std::from_chars(s.data(), s.data() + s.size(), result);
                                remain = res.ptr;
				freelocale(locale);
                        } else { // use C locale
                            auto res = std::from_chars(s.data(), s.data() + s.size(), result);
                            remain = res.ptr;
                        }

                        DEBUG_PARSER("PARSER:		Remain: '" << remain << "'");

			/* check conversion */
                        if(s.size() == strlen(remain))
				return 0;

                        DEBUG_PARSER("PARSER:		Result = " << result);
                        yyval->dval = result;

                                        p->pos += s.size() - strlen(remain);

			return NUM;
		}

		/* process symbol */
		if (isalpha (c) || c == '.') {
                        DEBUG_PARSER("PARSER: Found SYMBOL (starts with alpha)");
			static char *symbol_name = nullptr;
			static int length = 0;
			int i = 0;

			/* Initially make the buffer long enough for a 10-character symbol name */
			if (length == 0) {
				length = 10;
				symbol_name = (char *) malloc(length + 1);
			}

			do {
                                DEBUG_PARSER("PARSER: Reading symbol .. ");
				/* If buffer is full, make it bigger */
				if (i == length) {
					length *= 2;
					symbol_name = (char *) realloc(symbol_name, length + 1);
				}
				symbol_name[i++] = c;
				c = getcharstr(p);
                                DEBUG_PARSER("PARSER:		got '" << c << "'");
			}
			while (c != EOF && (isalnum(c) || c == '_' || c == '.'));
                        DEBUG_PARSER("PARSER: Reading SYMBOL DONE");

			if (c != EOF)
				ungetcstr(&(p->pos));
			symbol_name[i] = '\0';

			BaseSymbol* s = nullptr;
                        if (p->parser->usedSymbolsState() == UsedSymbols::Only) {
                                s = p->parser->get_used_symbol(symbol_name);
				if (s == nullptr) {
                                        //pdebug("PARSER ERROR: Used Symbol '%s' UNKNOWN\n", symbol_name);
//					p->errorCount++;
					return 0;
				}
			} else {
                                s = get_static_symbol(symbol_name);
				if(s == nullptr) {	/* symbol unknown */
                                        s = get_variable_symbol(symbol_name);
					if (s == nullptr) {
                                                //pdebug("PARSER ERROR: Symbol '%s' UNKNOWN\n", symbol_name);
//						p->errorCount++;
						return 0;
					}
					/* old behavior: add symbol */
					/* s = put_symbol(symbol_name, VAR); */
				}

                                if (p->parser->usedSymbolsState() == UsedSymbols::Initialize) {
					bool found = false;
//                                        for (const auto* s: p->parser->mUsedSymbols) {
//							if (s->name == symbol_name) {
//								found = true;
//								break;
//							}
//					}
                                        if (!p->parser->get_used_symbol(symbol_name)) {
                                                p->parser->mUsedSymbols.push_back(s);
                                                std::cout << "New symbol: " << s->name << std::endl;
                                        }
				}
			}
			assert(s);

                        yyval->tptr = s;
			return s->type;
		}

		/* else: single operator */
                //pdebug("PARSER: Found single operator '%c'\n", c);
		return c;
	}
} // namespace Parsing
